<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.6.1"/>
<!--BEGIN PROJECT_NAME--><title>GLFW: GLFW: Input guide</title><!--END PROJECT_NAME-->
<!--BEGIN !PROJECT_NAME--><title>GLFW: Input guide</title><!--END !PROJECT_NAME-->
<link href="$relpath^tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="$relpath^jquery.js"></script>
<script type="text/javascript" src="$relpath^dynsections.js"></script>
$treeview
$search
$mathjax
<link href="$relpath^$stylesheet" rel="stylesheet" type="text/css" />
$extrastylesheet
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!--BEGIN TITLEAREA-->
<div id="titlearea">
	<div class="glfwheader">
		<a href="http://www.glfw.org/" id="glfwhome">GLFW</a>
		<ul class="glfwnavbar">
			<li><a href="http://www.glfw.org/documentation.html">Documentation</a></li>
			<li><a href="http://www.glfw.org/download.html">Download</a></li>
			<li><a href="http://www.glfw.org/media.html">Media</a></li>
			<li><a href="http://www.glfw.org/community.html">Community</a></li>
		</ul>
	</div>
</div>
<!--END TITLEAREA-->
<!-- end header part -->
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="input">Input guide </a></h1><p>This guide introduces the input related functions of GLFW. There are also guides for the other areas of GLFW.</p>
<ul>
<li><a class="el" href="intro.html">Introduction to the API</a></li>
<li><a class="el" href="window.html">Window guide</a></li>
<li><a class="el" href="context.html">Context guide</a></li>
<li><a class="el" href="monitor.html">Monitor guide</a></li>
</ul>
<p>GLFW provides many kinds of input. While some can only be polled, like time, or only received via callbacks, like scrolling, there are those that provide both callbacks and polling. Where a callback is provided, that is the recommended way to receive that kind of input. The more you can use callbacks the less time your users' machines will need to spend polling.</p>
<p>All input callbacks receive a window handle. By using the [window user pointer](<a class="el" href="window.html#window_userptr">User pointer</a>), you can access non-global structures or objects from your callbacks.</p>
<p>To get a better feel for how the various events callbacks behave, run the `events` test program. It register every callback supported by GLFW and prints out all arguments provided for every event, along with time and sequence information.</p>
<h2><a class="anchor" id="events">
Event processing</a></h2>
<p>GLFW needs to communicate regularly with the window system both in order to receive events and to show that the application hasn't locked up. Event processing must be done regularly while you have visible windows and is normally done each frame after [buffer swapping](<a class="el" href="window.html#buffer_swap">Buffer swapping</a>).</p>
<p>There are two functions for processing pending events. <a class="el" href="group__window.html#ga37bd57223967b4211d60ca1a0bf3c832">glfwPollEvents</a>, processes only those events that have already been received and then returns immediately.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga37bd57223967b4211d60ca1a0bf3c832" title="Processes all pending events.">glfwPollEvents</a>();
</pre></div><p>This is the best choice when rendering continually, like most games do.</p>
<p>If you only need to update the contents of the window when you receive new input, <a class="el" href="group__window.html#ga554e37d781f0a997656c26b2c56c835e">glfwWaitEvents</a> is a better choice.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga554e37d781f0a997656c26b2c56c835e" title="Waits until events are queued and processes them.">glfwWaitEvents</a>();
</pre></div><p>It puts the thread to sleep until at least one event has been received and then processes all received events. This saves a great deal of CPU cycles and is useful for, for example, editing tools. There must be at least one GLFW window for this function to sleep.</p>
<p>If the main thread is sleeping in <a class="el" href="group__window.html#ga554e37d781f0a997656c26b2c56c835e">glfwWaitEvents</a>, you can wake it from another thread by posting an empty event to the event queue with <a class="el" href="group__window.html#gab5997a25187e9fd5c6f2ecbbc8dfd7e9">glfwPostEmptyEvent</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#gab5997a25187e9fd5c6f2ecbbc8dfd7e9" title="Posts an empty event to the event queue.">glfwPostEmptyEvent</a>();
</pre></div><p>Do not assume that callbacks will _only_ be called through either of the above functions. While it is necessary to process events in the event queue, some window systems will send some events directly to the application, which in turn causes callbacks to be called outside of regular event processing.</p>
<h2><a class="anchor" id="input_keyboard">
Keyboard input</a></h2>
<p>GLFW divides keyboard input into two categories; key events and character events. Key events relate to actual physical keyboard keys, whereas character events relate to the Unicode code points generated by pressing some of them.</p>
<p>Keys and characters do not map 1:1. A single key press may produce several characters, and a single character may require several keys to produce. This may not be the case on your machine, but your users are likely not all using the same keyboard layout, input method or even operating system as you.</p>
<h3><a class="anchor" id="input_key">
Key input</a></h3>
<p>If you wish to be notified when a physical key is pressed or released or when it repeats, set a key callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#ga7e496507126f35ea72f01b2e6ef6d155" title="Sets the key callback.">glfwSetKeyCallback</a>(window, key_callback);
</pre></div><p>The callback function receives the [keyboard key](<a class="el" href="group__keys.html">Keyboard keys</a>), platform-specific scancode, key action and [modifier bits](<a class="el" href="group__mods.html">Modifier key flags</a>).</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> key_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> key, <span class="keywordtype">int</span> scancode, <span class="keywordtype">int</span> action, <span class="keywordtype">int</span> mods)
{
    <span class="keywordflow">if</span> (key == <a class="code" href="group__keys.html#gabf48fcc3afbe69349df432b470c96ef2">GLFW_KEY_E</a> &amp;&amp; action == <a class="code" href="group__input.html#ga2485743d0b59df3791c45951c4195265">GLFW_PRESS</a>)
        activate_airship();
}
</pre></div><p>The action is one of `GLFW_PRESS`, `GLFW_REPEAT` or `GLFW_RELEASE`. The key will be `GLFW_KEY_UNKNOWN` if GLFW lacks a key token for it, for example _E-mail_ and _Play_ keys.</p>
<p>The scancode is unique for every key, regardless of whether it has a key token. Scancodes are platform-specific but consistent over time, so keys will have different scancodes depending on the platform but they are safe to save to disk.</p>
<p>Key states for [named keys](<a class="el" href="group__keys.html">Keyboard keys</a>) are also saved in per-window state arrays that can be polled with <a class="el" href="group__input.html#gadd341da06bc8d418b4dc3a3518af9ad2">glfwGetKey</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> state = <a class="code" href="group__input.html#gadd341da06bc8d418b4dc3a3518af9ad2" title="Returns the last reported state of a keyboard key for the specified window.">glfwGetKey</a>(window, <a class="code" href="group__keys.html#gabf48fcc3afbe69349df432b470c96ef2">GLFW_KEY_E</a>);
<span class="keywordflow">if</span> (state == <a class="code" href="group__input.html#ga2485743d0b59df3791c45951c4195265">GLFW_PRESS</a>)
    activate_airship();
</pre></div><p>The returned state is one of `GLFW_PRESS` or `GLFW_RELEASE`.</p>
<p>This function only returns cached key event state. It does not poll the system for the current state of the key.</p>
<p>Whenever you poll state, you risk missing the state change you are looking for. If a pressed key is released again before you poll its state, you will have missed the key press. The recommended solution for this is to use a key callback, but there is also the `GLFW_STICKY_KEYS` input mode.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gaa92336e173da9c8834558b54ee80563b" title="Sets an input option for the specified window.">glfwSetInputMode</a>(window, <a class="code" href="glfw3_8h.html#ae3bbe2315b7691ab088159eb6c9110fc">GLFW_STICKY_KEYS</a>, 1);
</pre></div><p>When sticky keys mode is enabled, the pollable state of a key will remain `GLFW_PRESS` until the state of that key is polled with <a class="el" href="group__input.html#gadd341da06bc8d418b4dc3a3518af9ad2">glfwGetKey</a>. Once it has been polled, if a key release event had been processed in the meantime, the state will reset to `GLFW_RELEASE`, otherwise it will remain `GLFW_PRESS`.</p>
<p>The `GLFW_KEY_LAST` constant holds the highest value of any [named key](<a class="el" href="group__keys.html">Keyboard keys</a>).</p>
<h3><a class="anchor" id="input_char">
Text input</a></h3>
<p>GLFW supports text input in the form of a stream of [Unicode code points](<a href="https://en.wikipedia.org/wiki/Unicode">https://en.wikipedia.org/wiki/Unicode</a>), as produced by the operating system text input system. Unlike key input, text input obeys keyboard layouts and modifier keys and supports composing characters using [dead keys](<a href="https://en.wikipedia.org/wiki/Dead_key">https://en.wikipedia.org/wiki/Dead_key</a>). Once received, you can encode the code points into [UTF-8](<a href="https://en.wikipedia.org/wiki/UTF-8">https://en.wikipedia.org/wiki/UTF-8</a>) or any other encoding you prefer.</p>
<p>Because an `unsigned int` is 32 bits long on all platforms supported by GLFW, you can treat the code point argument as native endian [UTF-32](<a href="https://en.wikipedia.org/wiki/UTF-32">https://en.wikipedia.org/wiki/UTF-32</a>).</p>
<p>There are two callbacks for receiving Unicode code points. If you wish to offer regular text input, set a character callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#ga556239421c6a5a243c66fca28da9f742" title="Sets the Unicode character callback.">glfwSetCharCallback</a>(window, character_callback);
</pre></div><p>The callback function receives Unicode code points for key events that would have led to regular text input and generally behaves as a standard text field on that platform.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> character_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> codepoint)
{
}
</pre></div><p>If you wish to receive even those Unicode code points generated with modifier key combinations that a plain text field would ignore, or just want to know exactly what modifier keys were used, set a character with modifiers callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#ga3f55ef5dc03a374e567f068b13c94afc" title="Sets the Unicode character with modifiers callback.">glfwSetCharModsCallback</a>(window, charmods_callback);
</pre></div><p>The callback function receives Unicode code points and [modifier bits](<a class="el" href="group__mods.html">Modifier key flags</a>).</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> charmods_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> codepoint, <span class="keywordtype">int</span> mods)
{
}
</pre></div><h2><a class="anchor" id="input_mouse">
Mouse input</a></h2>
<p>Mouse input comes in many forms, including cursor motion, button presses and scrolling offsets. The cursor appearance can also be changed, either to a custom image or a standard cursor shape from the system theme.</p>
<h3><a class="anchor" id="cursor_pos">
Cursor position</a></h3>
<p>If you wish to be notified when the cursor moves over the window, set a cursor position callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#ga7dad39486f2c7591af7fb25134a2501d" title="Sets the cursor position callback.">glfwSetCursorPosCallback</a>(window, cursor_pos_callback);
</pre></div><p>The callback functions receives the cursor position. On platforms that provide it, the full sub-pixel cursor position is passed on.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> cursor_position_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">double</span> xpos, <span class="keywordtype">double</span> ypos)
{
}
</pre></div><p>The cursor position is also saved per-window and can be polled with <a class="el" href="group__input.html#ga01d37b6c40133676b9cea60ca1d7c0cc">glfwGetCursorPos</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">double</span> xpos, ypos;
<a class="code" href="group__input.html#ga01d37b6c40133676b9cea60ca1d7c0cc" title="Retrieves the position of the cursor relative to the client area of the window.">glfwGetCursorPos</a>(window, &amp;xpos, &amp;ypos);
</pre></div><h3><a class="anchor" id="cursor_mode">
Cursor modes</a></h3>
<p>The `GLFW_CURSOR` input mode provides several cursor modes for special forms of mouse motion input. By default, the cursor mode is `GLFW_CURSOR_NORMAL`, meaning the regular arrow cursor (or another cursor set with <a class="el" href="group__input.html#gad3b4f38c8d5dae036bc8fa959e18343e">glfwSetCursor</a>) is used and cursor motion is not limited.</p>
<p>If you wish to implement mouse motion based camera controls or other input schemes that require unlimited mouse movement, set the cursor mode to `GLFW_CURSOR_DISABLED`.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gaa92336e173da9c8834558b54ee80563b" title="Sets an input option for the specified window.">glfwSetInputMode</a>(window, <a class="code" href="glfw3_8h.html#aade31da5b884a84a7625c6b059b9132c">GLFW_CURSOR</a>, <a class="code" href="glfw3_8h.html#a2315b99a329ce53e6a13a9d46fd5ca88">GLFW_CURSOR_DISABLED</a>);
</pre></div><p>This will hide the cursor and lock it to the specified window. GLFW will then take care of all the details of cursor re-centering and offset calculation and providing the application with a virtual cursor position. This virtual position is provided normally via both the cursor position callback and through polling.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>You should not implement your own version of this functionality using other features of GLFW. It is not supported and will not work as robustly as `GLFW_CURSOR_DISABLED`.</dd></dl>
<p>If you just wish the cursor to become hidden when it is over a window, set the cursor mode to `GLFW_CURSOR_HIDDEN`.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gaa92336e173da9c8834558b54ee80563b" title="Sets an input option for the specified window.">glfwSetInputMode</a>(window, <a class="code" href="glfw3_8h.html#aade31da5b884a84a7625c6b059b9132c">GLFW_CURSOR</a>, <a class="code" href="glfw3_8h.html#ac4d5cb9d78de8573349c58763d53bf11">GLFW_CURSOR_HIDDEN</a>);
</pre></div><p>This mode puts no limit on the motion of the cursor.</p>
<p>To exit out of either of these special modes, restore the `GLFW_CURSOR_NORMAL` cursor mode.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gaa92336e173da9c8834558b54ee80563b" title="Sets an input option for the specified window.">glfwSetInputMode</a>(window, <a class="code" href="glfw3_8h.html#aade31da5b884a84a7625c6b059b9132c">GLFW_CURSOR</a>, <a class="code" href="glfw3_8h.html#ae04dd25c8577e19fa8c97368561f6c68">GLFW_CURSOR_NORMAL</a>);
</pre></div><h3><a class="anchor" id="cursor_object">
Cursor objects</a></h3>
<p>GLFW supports creating both custom and system theme cursor images, encapsulated as <a class="el" href="glfw3_8h.html#a89261ae18c75e863aaf2656ecdd238f4">GLFWcursor</a> objects. They are created with <a class="el" href="group__input.html#gafca356935e10135016aa49ffa464c355">glfwCreateCursor</a> or <a class="el" href="group__input.html#gaa65f416d03ebbbb5b8db71a489fcb894">glfwCreateStandardCursor</a> and destroyed with <a class="el" href="group__input.html#ga81b952cd1764274d0db7fb3c5a79ba6a">glfwDestroyCursor</a>, or <a class="el" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a>, if any remain.</p>
<h4><a class="anchor" id="cursor_custom">
Custom cursor creation</a></h4>
<p>A custom cursor is created with <a class="el" href="group__input.html#gafca356935e10135016aa49ffa464c355">glfwCreateCursor</a>, which returns a handle to the created cursor object. For example, this creates a 16x16 white square cursor with the hot-spot in the upper-left corner:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> pixels[16 * 16 * 4];
memset(pixels, 0xff, <span class="keyword">sizeof</span>(pixels));

<a class="code" href="structGLFWimage.html" title="Image data.">GLFWimage</a> image;
image.<a class="code" href="structGLFWimage.html#af6a71cc999fe6d3aea31dd7e9687d835">width</a> = 16;
image.<a class="code" href="structGLFWimage.html#a0b7d95368f0c80d5e5c9875057c7dbec">height</a> = 16;
image.<a class="code" href="structGLFWimage.html#a0c532a5c2bb715555279b7817daba0fb">pixels</a> = pixels;

<a class="code" href="glfw3_8h.html#a89261ae18c75e863aaf2656ecdd238f4">GLFWcursor</a>* cursor = <a class="code" href="group__input.html#gafca356935e10135016aa49ffa464c355" title="Creates a custom cursor.">glfwCreateCursor</a>(&amp;image, 0, 0);
</pre></div><p>If cursor creation fails, `NULL` will be returned, so it is necessary to check the return value.</p>
<p>The image data is 32-bit, little-endian, non-premultiplied RGBA, i.e. eight bits per channel. The pixels are arranged canonically as sequential rows, starting from the top-left corner.</p>
<h4><a class="anchor" id="cursor_standard">
Standard cursor creation</a></h4>
<p>A cursor with a [standard shape](<a class="el" href="group__shapes.html">Standard cursor shapes</a>) from the current system cursor theme can be can be created with <a class="el" href="group__input.html#gaa65f416d03ebbbb5b8db71a489fcb894">glfwCreateStandardCursor</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="glfw3_8h.html#a89261ae18c75e863aaf2656ecdd238f4">GLFWcursor</a>* cursor = <a class="code" href="group__input.html#gaa65f416d03ebbbb5b8db71a489fcb894" title="Creates a cursor with a standard shape.">glfwCreateStandardCursor</a>(<a class="code" href="group__shapes.html#gabb3eb0109f11bb808fc34659177ca962">GLFW_HRESIZE_CURSOR</a>);
</pre></div><p>These cursor objects behave in the exact same way as those created with <a class="el" href="group__input.html#gafca356935e10135016aa49ffa464c355">glfwCreateCursor</a> except that the system cursor theme provides the actual image.</p>
<h4><a class="anchor" id="cursor_destruction">
Cursor destruction</a></h4>
<p>When a cursor is no longer needed, destroy it with <a class="el" href="group__input.html#ga81b952cd1764274d0db7fb3c5a79ba6a">glfwDestroyCursor</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#ga81b952cd1764274d0db7fb3c5a79ba6a" title="Destroys a cursor.">glfwDestroyCursor</a>(cursor);
</pre></div><p>Cursor destruction always succeeds. All cursors remaining when <a class="el" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a> is called are destroyed as well.</p>
<h4><a class="anchor" id="cursor_set">
Cursor setting</a></h4>
<p>A cursor can be set as current for a window with <a class="el" href="group__input.html#gad3b4f38c8d5dae036bc8fa959e18343e">glfwSetCursor</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gad3b4f38c8d5dae036bc8fa959e18343e" title="Sets the cursor for the window.">glfwSetCursor</a>(window, cursor);
</pre></div><p>Once set, the cursor image will be used as long as the system cursor is over the client area of the window and the [cursor mode](<a class="el" href="input.html#cursor_mode">Cursor modes</a>) is set to `GLFW_CURSOR_NORMAL`.</p>
<p>A single cursor may be set for any number of windows.</p>
<p>To remove a cursor from a window, set the cursor of that window to `NULL`.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gad3b4f38c8d5dae036bc8fa959e18343e" title="Sets the cursor for the window.">glfwSetCursor</a>(window, NULL);
</pre></div><p>When a cursor is destroyed, it is removed from any window where it is set. This does not affect the cursor modes of those windows.</p>
<h3><a class="anchor" id="cursor_enter">
Cursor enter/leave events</a></h3>
<p>If you wish to be notified when the cursor enters or leaves the client area of a window, set a cursor enter/leave callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gaa299c41dd0a3d171d166354e01279e04" title="Sets the cursor enter/exit callback.">glfwSetCursorEnterCallback</a>(window, cursor_enter_callback);
</pre></div><p>The callback function receives the new classification of the cursor.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> cursor_enter_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> entered)
{
    <span class="keywordflow">if</span> (entered)
    {
        <span class="comment">// The cursor entered the client area of the window</span>
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// The cursor left the client area of the window</span>
    }
}
</pre></div><h3><a class="anchor" id="input_mouse_button">
Mouse button input</a></h3>
<p>If you wish to be notified when a mouse button is pressed or released, set a mouse button callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gaef49b72d84d615bca0a6ed65485e035d" title="Sets the mouse button callback.">glfwSetMouseButtonCallback</a>(window, mouse_button_callback);
</pre></div><p>The callback function receives the [mouse button](<a class="el" href="group__buttons.html">Mouse buttons</a>), button action and [modifier bits](<a class="el" href="group__mods.html">Modifier key flags</a>).</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> mouse_button_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> button, <span class="keywordtype">int</span> action, <span class="keywordtype">int</span> mods)
{
    <span class="keywordflow">if</span> (button == <a class="code" href="group__buttons.html#ga3e2f2cf3c4942df73cc094247d275e74">GLFW_MOUSE_BUTTON_RIGHT</a> &amp;&amp; action == <a class="code" href="group__input.html#ga2485743d0b59df3791c45951c4195265">GLFW_PRESS</a>)
        popup_menu();
}
</pre></div><p>The action is one of `GLFW_PRESS` or `GLFW_RELEASE`.</p>
<p>Mouse button states for [named buttons](<a class="el" href="group__buttons.html">Mouse buttons</a>) are also saved in per-window state arrays that can be polled with <a class="el" href="group__input.html#gac1473feacb5996c01a7a5a33b5066704">glfwGetMouseButton</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> state = <a class="code" href="group__input.html#gac1473feacb5996c01a7a5a33b5066704" title="Returns the last reported state of a mouse button for the specified window.">glfwGetMouseButton</a>(window, <a class="code" href="group__buttons.html#gaf37100431dcd5082d48f95ee8bc8cd56">GLFW_MOUSE_BUTTON_LEFT</a>);
<span class="keywordflow">if</span> (state == <a class="code" href="group__input.html#ga2485743d0b59df3791c45951c4195265">GLFW_PRESS</a>)
    upgrade_cow();
</pre></div><p>The returned state is one of `GLFW_PRESS` or `GLFW_RELEASE`.</p>
<p>This function only returns cached mouse button event state. It does not poll the system for the current state of the mouse button.</p>
<p>Whenever you poll state, you risk missing the state change you are looking for. If a pressed mouse button is released again before you poll its state, you will have missed the button press. The recommended solution for this is to use a mouse button callback, but there is also the `GLFW_STICKY_MOUSE_BUTTONS` input mode.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gaa92336e173da9c8834558b54ee80563b" title="Sets an input option for the specified window.">glfwSetInputMode</a>(window, <a class="code" href="glfw3_8h.html#a4d7ce8ce71030c3b04e2b78145bc59d1">GLFW_STICKY_MOUSE_BUTTONS</a>, 1);
</pre></div><p>When sticky mouse buttons mode is enabled, the pollable state of a mouse button will remain `GLFW_PRESS` until the state of that button is polled with <a class="el" href="group__input.html#gac1473feacb5996c01a7a5a33b5066704">glfwGetMouseButton</a>. Once it has been polled, if a mouse button release event had been processed in the meantime, the state will reset to `GLFW_RELEASE`, otherwise it will remain `GLFW_PRESS`.</p>
<p>The `GLFW_MOUSE_BUTTON_LAST` constant holds the highest value of any [named button](<a class="el" href="group__buttons.html">Mouse buttons</a>).</p>
<h3><a class="anchor" id="scrolling">
Scroll input</a></h3>
<p>If you wish to be notified when the user scrolls, whether with a mouse wheel or touchpad gesture, set a scroll callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gacf02eb10504352f16efda4593c3ce60e" title="Sets the scroll callback.">glfwSetScrollCallback</a>(window, scroll_callback);
</pre></div><p>The callback function receives two-dimensional scroll offsets.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> scroll_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">double</span> xoffset, <span class="keywordtype">double</span> yoffset)
{
}
</pre></div><p>A simple mouse wheel, being vertical, provides offsets along the Y-axis.</p>
<h2><a class="anchor" id="joystick">
Joystick input</a></h2>
<p>The joystick functions expose connected joysticks and controllers, with both referred to as joysticks. It supports up to sixteen joysticks, ranging from `GLFW_JOYSTICK_1`, `GLFW_JOYSTICK_2` up to `GLFW_JOYSTICK_LAST`. You can test whether a [joystick](<a class="el" href="group__joysticks.html">Joysticks</a>) is present with <a class="el" href="group__input.html#gaffcbd9ac8ee737fcdd25475123a3c790">glfwJoystickPresent</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> present = <a class="code" href="group__input.html#gaffcbd9ac8ee737fcdd25475123a3c790" title="Returns whether the specified joystick is present.">glfwJoystickPresent</a>(<a class="code" href="group__joysticks.html#ga34a0443d059e9f22272cd4669073f73d">GLFW_JOYSTICK_1</a>);
</pre></div><p>When GLFW is initialized, detected joysticks are added to to the beginning of the array, starting with `GLFW_JOYSTICK_1`. Once a joystick is detected, it keeps its assigned index until it is disconnected, so as joysticks are connected and disconnected, they will become spread out.</p>
<p>Joystick state is updated as needed when a joystick function is called and does not require a window to be created or <a class="el" href="group__window.html#ga37bd57223967b4211d60ca1a0bf3c832">glfwPollEvents</a> or <a class="el" href="group__window.html#ga554e37d781f0a997656c26b2c56c835e">glfwWaitEvents</a> to be called.</p>
<h3><a class="anchor" id="joystick_axis">
Joystick axis states</a></h3>
<p>The positions of all axes of a joystick are returned by <a class="el" href="group__input.html#ga6271d46a5901ec2c99601ccf4dd14731">glfwGetJoystickAxes</a>. See the reference documentation for the lifetime of the returned array.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> count;
<span class="keyword">const</span> <span class="keywordtype">float</span>* axes = <a class="code" href="group__input.html#ga6271d46a5901ec2c99601ccf4dd14731" title="Returns the values of all axes of the specified joystick.">glfwGetJoystickAxes</a>(<a class="code" href="group__joysticks.html#ga34a0443d059e9f22272cd4669073f73d">GLFW_JOYSTICK_1</a>, &amp;count);
</pre></div><p>Each element in the returned array is a value between -1.0 and 1.0.</p>
<h3><a class="anchor" id="joystick_button">
Joystick button states</a></h3>
<p>The states of all buttons of a joystick are returned by <a class="el" href="group__input.html#gace54cd930dcd502e118fe4021384ce1b">glfwGetJoystickButtons</a>. See the reference documentation for the lifetime of the returned array.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> count;
<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* axes = <a class="code" href="group__input.html#gace54cd930dcd502e118fe4021384ce1b" title="Returns the state of all buttons of the specified joystick.">glfwGetJoystickButtons</a>(<a class="code" href="group__joysticks.html#ga34a0443d059e9f22272cd4669073f73d">GLFW_JOYSTICK_1</a>, &amp;count);
</pre></div><p>Each element in the returned array is either `GLFW_PRESS` or `GLFW_RELEASE`.</p>
<h3><a class="anchor" id="joystick_name">
Joystick name</a></h3>
<p>The human-readable, UTF-8 encoded name of a joystick is returned by <a class="el" href="group__input.html#gac8d7f6107e05cfd106cfba973ab51e19">glfwGetJoystickName</a>. See the reference documentation for the lifetime of the returned string.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">char</span>* name = <a class="code" href="group__input.html#gac8d7f6107e05cfd106cfba973ab51e19" title="Returns the name of the specified joystick.">glfwGetJoystickName</a>(<a class="code" href="group__joysticks.html#ga34a0443d059e9f22272cd4669073f73d">GLFW_JOYSTICK_1</a>);
</pre></div><p>Joystick names are not guaranteed to be unique. Two joysticks of the same model and make may have the same name. Only the [joystick token](<a class="el" href="group__joysticks.html">Joysticks</a>) is guaranteed to be unique, and only until that joystick is disconnected.</p>
<h2><a class="anchor" id="time">
Time input</a></h2>
<p>GLFW provides high-resolution time input, in seconds, with <a class="el" href="group__input.html#gaa6cf4e7a77158a3b8fd00328b1720a4a">glfwGetTime</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">double</span> seconds = <a class="code" href="group__input.html#gaa6cf4e7a77158a3b8fd00328b1720a4a" title="Returns the value of the GLFW timer.">glfwGetTime</a>();
</pre></div><p>It returns the number of seconds since the timer was started when the library was initialized with <a class="el" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a>. The platform-specific time sources used usually have micro- or nanosecond resolution.</p>
<p>You can modify the reference time with <a class="el" href="group__input.html#gaf59589ef6e8b8c8b5ad184b25afd4dc0">glfwSetTime</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gaf59589ef6e8b8c8b5ad184b25afd4dc0" title="Sets the GLFW timer.">glfwSetTime</a>(4.0);
</pre></div><p>This sets the timer to the specified time, in seconds.</p>
<h2><a class="anchor" id="clipboard">
Clipboard input and output</a></h2>
<p>If the system clipboard contains a UTF-8 encoded string or if it can be converted to one, you can retrieve it with <a class="el" href="group__input.html#ga5aba1d704d9ab539282b1fbe9f18bb94">glfwGetClipboardString</a>. See the reference documentation for the lifetime of the returned string.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">char</span>* text = <a class="code" href="group__input.html#ga5aba1d704d9ab539282b1fbe9f18bb94" title="Returns the contents of the clipboard as a string.">glfwGetClipboardString</a>(window);
<span class="keywordflow">if</span> (text)
    insert_text(text);
</pre></div><p>If the clipboard is empty or if its contents could not be converted, `NULL` is returned.</p>
<p>The contents of the system clipboard can be set to a UTF-8 encoded string with <a class="el" href="group__input.html#gaba1f022c5eb07dfac421df34cdcd31dd">glfwSetClipboardString</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#gaba1f022c5eb07dfac421df34cdcd31dd" title="Sets the clipboard to the specified string.">glfwSetClipboardString</a>(window, <span class="stringliteral">&quot;A string with words in it&quot;</span>);
</pre></div><p>The clipboard functions take a window handle argument because some window systems require a window to communicate with the system clipboard. Any valid window may be used.</p>
<h2><a class="anchor" id="path_drop">
Path drop input</a></h2>
<p>If you wish to receive the paths of files and/or directories dropped on a window, set a file drop callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__input.html#ga41291bf15dd3ff564b3143aa6dc74a4b" title="Sets the file drop callback.">glfwSetDropCallback</a>(window, drop_callback);
</pre></div><p>The callback function receives an array of paths encoded as UTF-8.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> drop_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> count, <span class="keyword">const</span> <span class="keywordtype">char</span>** paths)
{
    <span class="keywordtype">int</span> i;
    <span class="keywordflow">for</span> (i = 0;  i &lt; count;  i++)
        handle_dropped_file(paths[i]);
}
</pre></div><p>The path array and its strings are only valid until the file drop callback returns, as they may have been generated specifically for that event. You need to make a deep copy of the array if you want to keep the paths. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<address class="footer">
<p>
Last update on 13 Dec 2016 for GLFW 3.1.2
</p>
</address>
</body>
</html>
