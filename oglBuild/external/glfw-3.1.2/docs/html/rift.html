<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.6.1"/>
<!--BEGIN PROJECT_NAME--><title>GLFW: GLFW: Oculus Rift guide</title><!--END PROJECT_NAME-->
<!--BEGIN !PROJECT_NAME--><title>GLFW: Oculus Rift guide</title><!--END !PROJECT_NAME-->
<link href="$relpath^tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="$relpath^jquery.js"></script>
<script type="text/javascript" src="$relpath^dynsections.js"></script>
$treeview
$search
$mathjax
<link href="$relpath^$stylesheet" rel="stylesheet" type="text/css" />
$extrastylesheet
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!--BEGIN TITLEAREA-->
<div id="titlearea">
	<div class="glfwheader">
		<a href="http://www.glfw.org/" id="glfwhome">GLFW</a>
		<ul class="glfwnavbar">
			<li><a href="http://www.glfw.org/documentation.html">Documentation</a></li>
			<li><a href="http://www.glfw.org/download.html">Download</a></li>
			<li><a href="http://www.glfw.org/media.html">Media</a></li>
			<li><a href="http://www.glfw.org/community.html">Community</a></li>
		</ul>
	</div>
</div>
<!--END TITLEAREA-->
<!-- end header part -->
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="rift">Oculus Rift guide </a></h1><p>This guide is intended to fill in the gaps between the [Oculus PC SDK documentation](<a href="https://developer.oculus.com/documentation/">https://developer.oculus.com/documentation/</a>) and the rest of the GLFW documentation and is not a replacement for either. It requires you to use [native access](<a class="el" href="group__native.html">Native access</a>) and assumes a certain level of proficiency with LibOVR, platform specific APIs and your chosen development environment.</p>
<p>While GLFW has no explicit support for LibOVR, it is tested with and tries to interoperate well with it.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because of the speed of development of the Oculus SDK, this guide may become outdated before the next release. If this is a local copy of the documentation, you may want to check the GLFW website for updates. This revision of the guide is written against version 0.4.4 of the SDK.</dd></dl>
<h2><a class="anchor" id="rift_include">
Including the LibOVR and GLFW header files</a></h2>
<p>Both the OpenGL LibOVR header and the GLFW native header need macros telling them what OS you are building for. Because LibOVR only supports three major desktop platforms, this can be solved with canonical predefined macros.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#if defined(_WIN32)</span>
<span class="preprocessor"></span><span class="preprocessor"> #define GLFW_EXPOSE_NATIVE_WIN32</span>
<span class="preprocessor"></span><span class="preprocessor"> #define GLFW_EXPOSE_NATIVE_WGL</span>
<span class="preprocessor"></span><span class="preprocessor"> #define OVR_OS_WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">#elif defined(__APPLE__)</span>
<span class="preprocessor"></span><span class="preprocessor"> #define GLFW_EXPOSE_NATIVE_COCOA</span>
<span class="preprocessor"></span><span class="preprocessor"> #define GLFW_EXPOSE_NATIVE_NSGL</span>
<span class="preprocessor"></span><span class="preprocessor"> #define OVR_OS_MAC</span>
<span class="preprocessor"></span><span class="preprocessor">#elif defined(__linux__)</span>
<span class="preprocessor"></span><span class="preprocessor"> #define GLFW_EXPOSE_NATIVE_X11</span>
<span class="preprocessor"></span><span class="preprocessor"> #define GLFW_EXPOSE_NATIVE_GLX</span>
<span class="preprocessor"></span><span class="preprocessor"> #define OVR_OS_LINUX</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;<a class="code" href="glfw3_8h.html">GLFW/glfw3.h</a>&gt;</span>
<span class="preprocessor">#include &lt;<a class="code" href="glfw3native_8h.html">GLFW/glfw3native.h</a>&gt;</span>

<span class="preprocessor">#include &lt;OVR_CAPI_GL.h&gt;</span>
</pre></div><p>Both the GLFW and LibOVR headers by default attempt to include the standard OpenGL `GL/gl.h` header (`OpenGL/gl.h` on OS X). If you wish to use a different standard header or an [extension loading library](<a class="el" href="context.html#context_glext_auto">Loading extension with a loader library</a>), include that header before these.</p>
<h2><a class="anchor" id="rift_init">
Initializing LibOVR and GLFW</a></h2>
<p>LibOVR needs to be initialized before GLFW. This means calling at least `ovr_Initialize`, `ovrHmd_Create` and `ovrHmd_ConfigureTracking` before <a class="el" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a>. Similarly, LibOVR must be shut down after GLFW. This means calling `ovrHmd_Destroy` and `ovr_Shutdown` after <a class="el" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a>.</p>
<h2><a class="anchor" id="rift_direct">
Direct HMD mode</a></h2>
<p>Direct HMD mode is the recommended display mode for new applications, but the Oculus Rift runtime currently (January 2015) only supports this mode on Windows. In direct mode the HMD is not detectable as a GLFW monitor.</p>
<h3><a class="anchor" id="rift_direct_create">
Creating a window and context</a></h3>
<p>If the HMD is in direct mode you can use either a full screen or a windowed mode window, but full screen is only recommended if there is a monitor that supports the resolution of the HMD. Due to limitations in LibOVR, the size of the client area of the window must equal the resolution of the HMD.</p>
<p>If the resolution of the HMD is much larger than the regular monitor, the window may be resized by the window manager on creation. One way to avoid this is to make it undecorated with the [GLFW_DECORATED](<a class="el" href="window.html#window_hints_wnd">Window related hints</a>) window hint.</p>
<h3><a class="anchor" id="rift_direct_attach">
Attaching the window to the HMD</a></h3>
<p>Once you have created the window and context, you need to attach the native handle of the GLFW window to the HMD.</p>
<div class="fragment"><pre class="fragment">ovrHmd_AttachToWindow(hmd, <a class="code" href="group__native.html#gafe5079aa79038b0079fc09d5f0a8e667" title="Returns the `HWND` of the specified window.">glfwGetWin32Window</a>(window), NULL, NULL);
</pre></div><h2><a class="anchor" id="rift_extend">
Extend Desktop mode</a></h2>
<p>Extend desktop mode is a legacy display mode, but is still (January 2015) the only available mode on OS X and Linux, as well as on Windows machines that for technical reasons do not yet support direct HMD mode.</p>
<h3><a class="anchor" id="rift_extend_detect">
Detecting a HMD with GLFW</a></h3>
<p>If the HMD is in extend desktop mode you can deduce which GLFW monitor it corresponds to and create a full screen window on that monitor.</p>
<p>On Windows, the native display device name of a GLFW monitor corresponds to the display device name of the detected HMD as stored, in the `DisplayDeviceName` member of `ovrHmdDesc`.</p>
<p>On OS X, the native display ID of a GLFW monitor corresponds to the display ID of the detected HMD, as stored in the `DisplayId` member of `ovrHmdDesc`.</p>
<p>At the time of writing (January 2015), the Oculus SDK does not support detecting which monitor corresponds to the HMD in any sane fashion, but as long as the HMD is set up and rotated properly it can be found via the screen position and resolution provided by LibOVR. This method may instead find another monitor that is mirroring the HMD, but this only matters if you intend to change its video mode.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> i, count;
<a class="code" href="group__monitor.html#ga8d9efd1cde9426692c73fe40437d0ae3">GLFWmonitor</a>** monitors = <a class="code" href="group__monitor.html#ga3fba51c8bd36491d4712aa5bd074a537" title="Returns the currently connected monitors.">glfwGetMonitors</a>(&amp;count);

<span class="keywordflow">for</span> (i = 0;  i &lt; count;  i++)
{
<span class="preprocessor">#if defined(_WIN32)</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span> (strcmp(<a class="code" href="group__native.html#gac408b09a330749402d5d1fa1f5894dd9" title="Returns the display device name of the specified monitor.">glfwGetWin32Monitor</a>(monitors[i]), hmd-&gt;DisplayDeviceName) == 0)
        <span class="keywordflow">return</span> monitors[i];
<span class="preprocessor">#elif defined(__APPLE__)</span>
<span class="preprocessor"></span>    <span class="keywordflow">if</span> (<a class="code" href="group__native.html#gaf22f429aec4b1aab316142d66d9be3e6" title="Returns the `CGDirectDisplayID` of the specified monitor.">glfwGetCocoaMonitor</a>(monitors[i]) == hmd-&gt;DisplayId)
        <span class="keywordflow">return</span> monitors[i];
<span class="preprocessor">#elif defined(__linux__)</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> xpos, ypos;
    <span class="keyword">const</span> <a class="code" href="structGLFWvidmode.html" title="Video mode type.">GLFWvidmode</a>* mode = <a class="code" href="group__monitor.html#gafc1bb972a921ad5b3bd5d63a95fc2d52" title="Returns the current mode of the specified monitor.">glfwGetVideoMode</a>(monitors[i]);
    <a class="code" href="group__monitor.html#ga102f54e7acc9149edbcf0997152df8c9" title="Returns the position of the monitor&amp;#39;s viewport on the virtual screen.">glfwGetMonitorPos</a>(monitors[i], &amp;xpos, &amp;ypos);

    <span class="keywordflow">if</span> (hmd-&gt;WindowsPos.x == xpos &amp;&amp;
        hmd-&gt;WindowsPos.y == ypos &amp;&amp;
        hmd-&gt;Resolution.w == mode-&gt;<a class="code" href="structGLFWvidmode.html#a698dcb200562051a7249cb6ae154c71d">width</a> &amp;&amp;
        hmd-&gt;Resolution.h == mode-&gt;<a class="code" href="structGLFWvidmode.html#ac65942a5f6981695517437a9d571d03c">height</a>)
    {
        <span class="keywordflow">return</span> monitors[i];
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor">}</span>
</pre></div><h3><a class="anchor" id="rift_extend_create">
Creating a window and context</a></h3>
<p>The window is created as a regular full screen window on the found monitor. It is usually a good idea to create a [windowed full screen](<a class="el" href="window.html#window_windowed_full_screen">"Windowed full screen" windows</a>) window, as the HMD will very likely already be set to the correct video mode. However, in extend desktop mode it behaves like a regular monitor and any supported video mode can be requested.</p>
<p>If other monitors are mirroring the HMD and you request a different video mode, all monitors in the mirroring set will get the new video mode.</p>
<h2><a class="anchor" id="rift_render">
Rendering to the HMD</a></h2>
<h3><a class="anchor" id="rift_render_sdk">
SDK distortion rendering</a></h3>
<p>If you wish to use SDK distortion rendering you will need some information from GLFW to configure the renderer. Below are the parts of the `ovrGLConfig` union that need to be filled with from GLFW. Note that there are other fields that also need to be filled for `ovrHmd_ConfigureRendering` to succeed.</p>
<p>Before configuring SDK distortion rendering you should make your context current.</p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> width, height;
    <span class="keyword">union </span>ovrGLConfig config;

    <a class="code" href="group__window.html#ga0e2637a4161afb283f5300c7f94785c9" title="Retrieves the size of the framebuffer of the specified window.">glfwGetFramebufferSize</a>(window, &amp;width, &amp;height);

    config.OGL.Header.BackBufferSize.w = width;
    config.OGL.Header.BackBufferSize.h = height;
<span class="preprocessor">#if defined(_WIN32)</span>
<span class="preprocessor"></span>    config.OGL.Window = <a class="code" href="group__native.html#gafe5079aa79038b0079fc09d5f0a8e667" title="Returns the `HWND` of the specified window.">glfwGetWin32Window</a>(window);
<span class="preprocessor">#elif defined(__APPLE__)</span>
<span class="preprocessor"></span><span class="preprocessor">#elif defined(__linux__)</span>
<span class="preprocessor"></span>    config.OGL.Disp = <a class="code" href="group__native.html#ga8519b66594ea3ef6eeafaa2e3ee37406" title="Returns the `Display` used by GLFW.">glfwGetX11Display</a>();
<span class="preprocessor">#endif</span>
</pre></div><p>When using SDK distortion rendering you should not swap the buffers yourself, as the HMD is updated by `ovrHmd_EndFrame`.</p>
<h3><a class="anchor" id="rift_render_custom">
Client distortion rendering</a></h3>
<p>With client distortion rendering you are in full control of the contents of the HMD and should render and swap the buffers normally. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<address class="footer">
<p>
Last update on 13 Dec 2016 for GLFW 3.1.2
</p>
</address>
</body>
</html>
