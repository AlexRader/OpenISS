<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.6.1"/>
<!--BEGIN PROJECT_NAME--><title>GLFW: GLFW: Window guide</title><!--END PROJECT_NAME-->
<!--BEGIN !PROJECT_NAME--><title>GLFW: Window guide</title><!--END !PROJECT_NAME-->
<link href="$relpath^tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="$relpath^jquery.js"></script>
<script type="text/javascript" src="$relpath^dynsections.js"></script>
$treeview
$search
$mathjax
<link href="$relpath^$stylesheet" rel="stylesheet" type="text/css" />
$extrastylesheet
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->

<!--BEGIN TITLEAREA-->
<div id="titlearea">
	<div class="glfwheader">
		<a href="http://www.glfw.org/" id="glfwhome">GLFW</a>
		<ul class="glfwnavbar">
			<li><a href="http://www.glfw.org/documentation.html">Documentation</a></li>
			<li><a href="http://www.glfw.org/download.html">Download</a></li>
			<li><a href="http://www.glfw.org/media.html">Media</a></li>
			<li><a href="http://www.glfw.org/community.html">Community</a></li>
		</ul>
	</div>
</div>
<!--END TITLEAREA-->
<!-- end header part -->
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="window">Window guide </a></h1><p>This guide introduces the window related functions of GLFW. There are also guides for the other areas of GLFW.</p>
<ul>
<li><a class="el" href="intro.html">Introduction to the API</a></li>
<li><a class="el" href="context.html">Context guide</a></li>
<li><a class="el" href="monitor.html">Monitor guide</a></li>
<li><a class="el" href="input.html">Input guide</a></li>
</ul>
<h2><a class="anchor" id="window_object">
Window objects</a></h2>
<p>The <a class="el" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a> object encapsulates both a window and a context. They are created with <a class="el" href="group__window.html#ga5c336fddf2cbb5b92f65f10fb6043344">glfwCreateWindow</a> and destroyed with <a class="el" href="group__window.html#gacdf43e51376051d2c091662e9fe3d7b2">glfwDestroyWindow</a>, or <a class="el" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a>, if any remain. As the window and context are inseparably linked, the object pointer is used as both a context and window handle.</p>
<p>To see the event stream provided to the various window related callbacks, run the `events` test program.</p>
<h3><a class="anchor" id="window_creation">
Window creation</a></h3>
<p>A window and its OpenGL or OpenGL ES context are created with <a class="el" href="group__window.html#ga5c336fddf2cbb5b92f65f10fb6043344">glfwCreateWindow</a>, which returns a handle to the created window object. For example, this creates a 640 by 480 windowed mode window:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window = <a class="code" href="group__window.html#ga5c336fddf2cbb5b92f65f10fb6043344" title="Creates a window and its associated context.">glfwCreateWindow</a>(640, 480, <span class="stringliteral">&quot;My Title&quot;</span>, NULL, NULL);
</pre></div><p>If window creation fails, `NULL` will be returned, so it is necessary to check the return value.</p>
<p>The window handle is passed to all window related functions and is provided to along with all input events, so event handlers can tell which window received the event.</p>
<h4><a class="anchor" id="window_full_screen">
Full screen windows</a></h4>
<p>To create a full screen window, you need to specify which monitor the window should use. In most cases, the user's primary monitor is a good choice. For more information about retrieving monitors, see <a class="el" href="monitor.html#monitor_monitors">Retrieving monitors</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window = <a class="code" href="group__window.html#ga5c336fddf2cbb5b92f65f10fb6043344" title="Creates a window and its associated context.">glfwCreateWindow</a>(640, 480, <span class="stringliteral">&quot;My Title&quot;</span>, <a class="code" href="group__monitor.html#ga721867d84c6d18d6790d64d2847ca0b1" title="Returns the primary monitor.">glfwGetPrimaryMonitor</a>(), NULL);
</pre></div><p>Full screen windows cover the entire display area of a monitor, have no border or decorations.</p>
<p>Each field of the <a class="el" href="structGLFWvidmode.html">GLFWvidmode</a> structure corresponds to a function parameter or window hint and combine to form the _desired video mode_ for that window. The supported video mode most closely matching the desired video mode will be set for the chosen monitor as long as the window has input focus. For more information about retrieving video modes, see <a class="el" href="monitor.html#monitor_modes">Video modes</a>.</p>
<p>Video mode field | Corresponds to ----------------------- | ------------------------ <a class="el" href="structGLFWvidmode.html#a698dcb200562051a7249cb6ae154c71d">GLFWvidmode.width</a> | `width` parameter <a class="el" href="structGLFWvidmode.html#ac65942a5f6981695517437a9d571d03c">GLFWvidmode.height</a> | `height` parameter <a class="el" href="structGLFWvidmode.html#a6066c4ecd251098700062d3b735dba1b">GLFWvidmode.redBits</a> | `GLFW_RED_BITS` hint <a class="el" href="structGLFWvidmode.html#a292fdd281f3485fb3ff102a5bda43faa">GLFWvidmode.greenBits</a> | `GLFW_GREEN_BITS` hint <a class="el" href="structGLFWvidmode.html#af310977f58d2e3b188175b6e3d314047">GLFWvidmode.blueBits</a> | `GLFW_BLUE_BITS` hint <a class="el" href="structGLFWvidmode.html#a791bdd6c7697b09f7e9c97054bf05649">GLFWvidmode.refreshRate</a> | `GLFW_REFRESH_RATE` hint</p>
<p>Once you have a full screen window, you can change its resolution with <a class="el" href="group__window.html#ga371911f12c74c504dd8d47d832d095cb">glfwSetWindowSize</a>. The new video mode will be selected and set the same way as the video mode chosen by <a class="el" href="group__window.html#ga5c336fddf2cbb5b92f65f10fb6043344">glfwCreateWindow</a>.</p>
<p>By default, the original video mode of the monitor will be restored and the window iconified if it loses input focus, to allow the user to switch back to the desktop. This behavior can be disabled with the `GLFW_AUTO_ICONIFY` window hint, for example if you wish to simultaneously cover multiple windows with full screen windows.</p>
<h4><a class="anchor" id="window_windowed_full_screen">
"Windowed full screen" windows</a></h4>
<p>If the closest match for the desired video mode is the current one, the video mode will not be changed, making window creation faster and application switching much smoother. This is sometimes called _windowed full screen_ or _borderless full screen_ window and counts as a full screen window. To create such a window, simply request the current video mode.</p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <a class="code" href="structGLFWvidmode.html" title="Video mode type.">GLFWvidmode</a>* mode = <a class="code" href="group__monitor.html#gafc1bb972a921ad5b3bd5d63a95fc2d52" title="Returns the current mode of the specified monitor.">glfwGetVideoMode</a>(monitor);

<a class="code" href="group__window.html#ga4fd9e504bb937e79588a0ffdca9f620b" title="Sets the specified window hint to the desired value.">glfwWindowHint</a>(<a class="code" href="glfw3_8h.html#af78ed8e417dbcc1e354906cc2708c982">GLFW_RED_BITS</a>, mode-&gt;<a class="code" href="structGLFWvidmode.html#a6066c4ecd251098700062d3b735dba1b">redBits</a>);
<a class="code" href="group__window.html#ga4fd9e504bb937e79588a0ffdca9f620b" title="Sets the specified window hint to the desired value.">glfwWindowHint</a>(<a class="code" href="glfw3_8h.html#afba3b72638c914e5fb8a237dd4c50d4d">GLFW_GREEN_BITS</a>, mode-&gt;<a class="code" href="structGLFWvidmode.html#a292fdd281f3485fb3ff102a5bda43faa">greenBits</a>);
<a class="code" href="group__window.html#ga4fd9e504bb937e79588a0ffdca9f620b" title="Sets the specified window hint to the desired value.">glfwWindowHint</a>(<a class="code" href="glfw3_8h.html#ab292ea403db6d514537b515311bf9ae3">GLFW_BLUE_BITS</a>, mode-&gt;<a class="code" href="structGLFWvidmode.html#af310977f58d2e3b188175b6e3d314047">blueBits</a>);
<a class="code" href="group__window.html#ga4fd9e504bb937e79588a0ffdca9f620b" title="Sets the specified window hint to the desired value.">glfwWindowHint</a>(<a class="code" href="glfw3_8h.html#a0f20825e6e47ee8ba389024519682212">GLFW_REFRESH_RATE</a>, mode-&gt;<a class="code" href="structGLFWvidmode.html#a791bdd6c7697b09f7e9c97054bf05649">refreshRate</a>);

<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window = <a class="code" href="group__window.html#ga5c336fddf2cbb5b92f65f10fb6043344" title="Creates a window and its associated context.">glfwCreateWindow</a>(mode-&gt;<a class="code" href="structGLFWvidmode.html#a698dcb200562051a7249cb6ae154c71d">width</a>, mode-&gt;<a class="code" href="structGLFWvidmode.html#ac65942a5f6981695517437a9d571d03c">height</a>, <span class="stringliteral">&quot;My Title&quot;</span>, monitor, NULL);
</pre></div><h3><a class="anchor" id="window_destruction">
Window destruction</a></h3>
<p>When a window is no longer needed, destroy it with <a class="el" href="group__window.html#gacdf43e51376051d2c091662e9fe3d7b2">glfwDestroyWindow</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#gacdf43e51376051d2c091662e9fe3d7b2" title="Destroys the specified window and its context.">glfwDestroyWindow</a>(window);
</pre></div><p>Window destruction always succeeds. Before the actual destruction, all callbacks are removed so no further events will be delivered for the window. All windows remaining when <a class="el" href="group__init.html#gaaae48c0a18607ea4a4ba951d939f0901">glfwTerminate</a> is called are destroyed as well.</p>
<p>When a full screen window is destroyed, the original video mode of its monitor is restored, but the gamma ramp is left untouched.</p>
<h3><a class="anchor" id="window_hints">
Window creation hints</a></h3>
<p>There are a number of hints that can be set before the creation of a window and context. Some affect the window itself, others affect the framebuffer or context. These hints are set to their default values each time the library is initialized with <a class="el" href="group__init.html#ga317aac130a235ab08c6db0834907d85e">glfwInit</a>, can be set individually with <a class="el" href="group__window.html#ga4fd9e504bb937e79588a0ffdca9f620b">glfwWindowHint</a> and reset all at once to their defaults with <a class="el" href="group__window.html#gaa77c4898dfb83344a6b4f76aa16b9a4a">glfwDefaultWindowHints</a>.</p>
<p>Note that hints need to be set _before_ the creation of the window and context you wish to have the specified attributes.</p>
<h4><a class="anchor" id="window_hints_hard">
Hard and soft constraints</a></h4>
<p>Some window hints are hard constraints. These must match the available capabilities _exactly_ for window and context creation to succeed. Hints that are not hard constraints are matched as closely as possible, but the resulting context and framebuffer may differ from what these hints requested.</p>
<p>The following hints are always hard constraints:</p>
<ul>
<li>`GLFW_STEREO`</li>
<li>`GLFW_DOUBLEBUFFER`</li>
<li>`GLFW_CLIENT_API`</li>
</ul>
<p>The following additional hints are hard constraints when requesting an OpenGL context, but are ignored when requesting an OpenGL ES context:</p>
<ul>
<li>`GLFW_OPENGL_FORWARD_COMPAT`</li>
<li>`GLFW_OPENGL_PROFILE`</li>
</ul>
<h4><a class="anchor" id="window_hints_wnd">
Window related hints</a></h4>
<p>`GLFW_RESIZABLE` specifies whether the windowed mode window will be resizable _by the user_. The window will still be resizable using the <a class="el" href="group__window.html#ga371911f12c74c504dd8d47d832d095cb">glfwSetWindowSize</a> function. This hint is ignored for full screen windows.</p>
<p>`GLFW_VISIBLE` specifies whether the windowed mode window will be initially visible. This hint is ignored for full screen windows.</p>
<p>`GLFW_DECORATED` specifies whether the windowed mode window will have window decorations such as a border, a close widget, etc. An undecorated window may still allow the user to generate close events on some platforms. This hint is ignored for full screen windows.</p>
<p>`GLFW_FOCUSED` specifies whether the windowed mode window will be given input focus when created. This hint is ignored for full screen and initially hidden windows.</p>
<p>`GLFW_AUTO_ICONIFY` specifies whether the full screen window will automatically iconify and restore the previous video mode on input focus loss. This hint is ignored for windowed mode windows.</p>
<p>`GLFW_FLOATING` specifies whether the windowed mode window will be floating above other regular windows, also called topmost or always-on-top. This is intended primarily for debugging purposes and cannot be used to implement proper full screen windows. This hint is ignored for full screen windows.</p>
<h4><a class="anchor" id="window_hints_fb">
Framebuffer related hints</a></h4>
<p>`GLFW_RED_BITS`, `GLFW_GREEN_BITS`, `GLFW_BLUE_BITS`, `GLFW_ALPHA_BITS`, `GLFW_DEPTH_BITS` and `GLFW_STENCIL_BITS` specify the desired bit depths of the various components of the default framebuffer. `GLFW_DONT_CARE` means the application has no preference.</p>
<p>`GLFW_ACCUM_RED_BITS`, `GLFW_ACCUM_GREEN_BITS`, `GLFW_ACCUM_BLUE_BITS` and `GLFW_ACCUM_ALPHA_BITS` specify the desired bit depths of the various components of the accumulation buffer. `GLFW_DONT_CARE` means the application has no preference.</p>
<dl class="user"><dt><b></b></dt><dd>Accumulation buffers are a legacy OpenGL feature and should not be used in new code.</dd></dl>
<p>`GLFW_AUX_BUFFERS` specifies the desired number of auxiliary buffers. `GLFW_DONT_CARE` means the application has no preference.</p>
<dl class="user"><dt><b></b></dt><dd>Auxiliary buffers are a legacy OpenGL feature and should not be used in new code.</dd></dl>
<p>`GLFW_STEREO` specifies whether to use stereoscopic rendering. This is a hard constraint.</p>
<p>`GLFW_SAMPLES` specifies the desired number of samples to use for multisampling. Zero disables multisampling. `GLFW_DONT_CARE` means the application has no preference.</p>
<p>`GLFW_SRGB_CAPABLE` specifies whether the framebuffer should be sRGB capable. If supported, the created context will provide `GL_ARB_framebuffer_sRGB` or `GL_EXT_framebuffer_sRGB`.</p>
<p>`GLFW_DOUBLEBUFFER` specifies whether the framebuffer should be double buffered. You nearly always want to use double buffering. This is a hard constraint.</p>
<h4><a class="anchor" id="window_hints_mtr">
Monitor related hints</a></h4>
<p>`GLFW_REFRESH_RATE` specifies the desired refresh rate for full screen windows. If set to `GLFW_DONT_CARE`, the highest available refresh rate will be used. This hint is ignored for windowed mode windows.</p>
<h4><a class="anchor" id="window_hints_ctx">
Context related hints</a></h4>
<p>`GLFW_CLIENT_API` specifies which client API to create the context for. Possible values are `GLFW_OPENGL_API` and `GLFW_OPENGL_ES_API`. This is a hard constraint.</p>
<p>`GLFW_CONTEXT_VERSION_MAJOR` and `GLFW_CONTEXT_VERSION_MINOR` specify the client API version that the created context must be compatible with. The exact behavior of these hints depend on the requested client API.</p>
<dl class="user"><dt><b></b></dt><dd>__OpenGL:__ `GLFW_CONTEXT_VERSION_MAJOR` and `GLFW_CONTEXT_VERSION_MINOR` are not hard constraints, but creation will fail if the OpenGL version of the created context is less than the one requested. It is therefore perfectly safe to use the default of version 1.0 for legacy code and you may still get backwards-compatible contexts of version 3.0 and above when available.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>While there is no way to ask the driver for a context of the highest supported version, GLFW will attempt to provide this when you ask for a version 1.0 context, which is the default for these hints.</dd></dl>
<dl class="user"><dt><b></b></dt><dd>__OpenGL ES:__ `GLFW_CONTEXT_VERSION_MAJOR` and `GLFW_CONTEXT_VERSION_MINOR` are not hard constraints, but creation will fail if the OpenGL ES version of the created context is less than the one requested. Additionally, OpenGL ES 1.x cannot be returned if 2.0 or later was requested, and vice versa. This is because OpenGL ES 3.x is backward compatible with 2.0, but OpenGL ES 2.0 is not backward compatible with 1.x.</dd></dl>
<p>`GLFW_OPENGL_FORWARD_COMPAT` specifies whether the OpenGL context should be forward-compatible, i.e. one where all functionality deprecated in the requested version of OpenGL is removed. This may only be used if the requested OpenGL version is 3.0 or above. If OpenGL ES is requested, this hint is ignored.</p>
<dl class="user"><dt><b></b></dt><dd>Forward-compatibility is described in detail in the [OpenGL Reference Manual](<a href="https://www.opengl.org/registry/">https://www.opengl.org/registry/</a>).</dd></dl>
<p>`GLFW_OPENGL_DEBUG_CONTEXT` specifies whether to create a debug OpenGL context, which may have additional error and performance issue reporting functionality. If OpenGL ES is requested, this hint is ignored.</p>
<p>`GLFW_OPENGL_PROFILE` specifies which OpenGL profile to create the context for. Possible values are one of `GLFW_OPENGL_CORE_PROFILE` or `GLFW_OPENGL_COMPAT_PROFILE`, or `GLFW_OPENGL_ANY_PROFILE` to not request a specific profile. If requesting an OpenGL version below 3.2, `GLFW_OPENGL_ANY_PROFILE` must be used. If OpenGL ES is requested, this hint is ignored.</p>
<dl class="user"><dt><b></b></dt><dd>OpenGL profiles are described in detail in the [OpenGL Reference Manual](<a href="https://www.opengl.org/registry/">https://www.opengl.org/registry/</a>).</dd></dl>
<p>`GLFW_CONTEXT_ROBUSTNESS` specifies the robustness strategy to be used by the context. This can be one of `GLFW_NO_RESET_NOTIFICATION` or `GLFW_LOSE_CONTEXT_ON_RESET`, or `GLFW_NO_ROBUSTNESS` to not request a robustness strategy.</p>
<p>`GLFW_CONTEXT_RELEASE_BEHAVIOR` specifies the release behavior to be used by the context. Possible values are one of `GLFW_ANY_RELEASE_BEHAVIOR`, `GLFW_RELEASE_BEHAVIOR_FLUSH` or `GLFW_RELEASE_BEHAVIOR_NONE`. If the behavior is `GLFW_ANY_RELEASE_BEHAVIOR`, the default behavior of the context creation API will be used. If the behavior is `GLFW_RELEASE_BEHAVIOR_FLUSH`, the pipeline will be flushed whenever the context is released from being the current one. If the behavior is `GLFW_RELEASE_BEHAVIOR_NONE`, the pipeline will not be flushed on release.</p>
<dl class="user"><dt><b></b></dt><dd>Context release behaviors are described in detail by the [GL_KHR_context_flush_control](<a href="https://www.opengl.org/registry/specs/KHR/context_flush_control.txt">https://www.opengl.org/registry/specs/KHR/context_flush_control.txt</a>) extension.</dd></dl>
<h4><a class="anchor" id="window_hints_values">
Supported and default values</a></h4>
<p>Window hint | Default value | Supported values ------------------------------- | --------------------------- | ---------------- `GLFW_RESIZABLE` | `GL_TRUE` | `GL_TRUE` or `GL_FALSE` `GLFW_VISIBLE` | `GL_TRUE` | `GL_TRUE` or `GL_FALSE` `GLFW_DECORATED` | `GL_TRUE` | `GL_TRUE` or `GL_FALSE` `GLFW_FOCUSED` | `GL_TRUE` | `GL_TRUE` or `GL_FALSE` `GLFW_AUTO_ICONIFY` | `GL_TRUE` | `GL_TRUE` or `GL_FALSE` `GLFW_FLOATING` | `GL_FALSE` | `GL_TRUE` or `GL_FALSE` `GLFW_RED_BITS` | 8 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_GREEN_BITS` | 8 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_BLUE_BITS` | 8 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_ALPHA_BITS` | 8 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_DEPTH_BITS` | 24 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_STENCIL_BITS` | 8 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_ACCUM_RED_BITS` | 0 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_ACCUM_GREEN_BITS` | 0 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_ACCUM_BLUE_BITS` | 0 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_ACCUM_ALPHA_BITS` | 0 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_AUX_BUFFERS` | 0 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_SAMPLES` | 0 | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_REFRESH_RATE` | `GLFW_DONT_CARE` | 0 to `INT_MAX` or `GLFW_DONT_CARE` `GLFW_STEREO` | `GL_FALSE` | `GL_TRUE` or `GL_FALSE` `GLFW_SRGB_CAPABLE` | `GL_FALSE` | `GL_TRUE` or `GL_FALSE` `GLFW_DOUBLEBUFFER` | `GL_TRUE` | `GL_TRUE` or `GL_FALSE` `GLFW_CLIENT_API` | `GLFW_OPENGL_API` | `GLFW_OPENGL_API` or `GLFW_OPENGL_ES_API` `GLFW_CONTEXT_VERSION_MAJOR` | 1 | Any valid major version number of the chosen client API `GLFW_CONTEXT_VERSION_MINOR` | 0 | Any valid minor version number of the chosen client API `GLFW_CONTEXT_ROBUSTNESS` | `GLFW_NO_ROBUSTNESS` | `GLFW_NO_ROBUSTNESS`, `GLFW_NO_RESET_NOTIFICATION` or `GLFW_LOSE_CONTEXT_ON_RESET` `GLFW_CONTEXT_RELEASE_BEHAVIOR` | `GLFW_ANY_RELEASE_BEHAVIOR` | `GLFW_ANY_RELEASE_BEHAVIOR`, `GLFW_RELEASE_BEHAVIOR_FLUSH` or `GLFW_RELEASE_BEHAVIOR_NONE` `GLFW_OPENGL_FORWARD_COMPAT` | `GL_FALSE` | `GL_TRUE` or `GL_FALSE` `GLFW_OPENGL_DEBUG_CONTEXT` | `GL_FALSE` | `GL_TRUE` or `GL_FALSE` `GLFW_OPENGL_PROFILE` | `GLFW_OPENGL_ANY_PROFILE` | `GLFW_OPENGL_ANY_PROFILE`, `GLFW_OPENGL_COMPAT_PROFILE` or `GLFW_OPENGL_CORE_PROFILE`</p>
<h2><a class="anchor" id="window_events">
Window event processing</a></h2>
<p>See <a class="el" href="input.html#events">Event processing</a>.</p>
<h2><a class="anchor" id="window_properties">
Window properties and events</a></h2>
<h3><a class="anchor" id="window_userptr">
User pointer</a></h3>
<p>Each window has a user pointer that can be set with <a class="el" href="group__window.html#ga3d2fc6026e690ab31a13f78bc9fd3651">glfwSetWindowUserPointer</a> and fetched with <a class="el" href="group__window.html#ga17807ce0f45ac3f8bb50d6dcc59a4e06">glfwGetWindowUserPointer</a>. This can be used for any purpose you need and will not be modified by GLFW throughout the life-time of the window.</p>
<p>The initial value of the pointer is `NULL`.</p>
<h3><a class="anchor" id="window_close">
Window closing and close flag</a></h3>
<p>When the user attempts to close the window, for example by clicking the close widget or using a key chord like Alt+F4, the _close flag_ of the window is set. The window is however not actually destroyed and, unless you watch for this state change, nothing further happens.</p>
<p>The current state of the close flag is returned by <a class="el" href="group__window.html#ga24e02fbfefbb81fc45320989f8140ab5">glfwWindowShouldClose</a> and can be set or cleared directly with <a class="el" href="group__window.html#ga49c449dde2a6f87d996f4daaa09d6708">glfwSetWindowShouldClose</a>. A common pattern is to use the close flag as a main loop condition.</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">while</span> (!<a class="code" href="group__window.html#ga24e02fbfefbb81fc45320989f8140ab5" title="Checks the close flag of the specified window.">glfwWindowShouldClose</a>(window))
{
    render(window);

    <a class="code" href="group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14" title="Swaps the front and back buffers of the specified window.">glfwSwapBuffers</a>(window);
    <a class="code" href="group__window.html#ga37bd57223967b4211d60ca1a0bf3c832" title="Processes all pending events.">glfwPollEvents</a>();
}
</pre></div><p>If you wish to be notified when the user attempts to close a window, set a close callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#gaade9264e79fae52bdb78e2df11ee8d6a" title="Sets the close callback for the specified window.">glfwSetWindowCloseCallback</a>(window, window_close_callback);
</pre></div><p>The callback function is called directly _after_ the close flag has been set. It can be used for example to filter close requests and clear the close flag again unless certain conditions are met.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> window_close_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window)
{
    <span class="keywordflow">if</span> (!time_to_close)
        <a class="code" href="group__window.html#ga49c449dde2a6f87d996f4daaa09d6708" title="Sets the close flag of the specified window.">glfwSetWindowShouldClose</a>(window, GL_FALSE);
}
</pre></div><h3><a class="anchor" id="window_size">
Window size</a></h3>
<p>The size of a window can be changed with <a class="el" href="group__window.html#ga371911f12c74c504dd8d47d832d095cb">glfwSetWindowSize</a>. For windowed mode windows, this sets the size, in [screen coordinates](<a class="el" href="intro.html#coordinate_systems">Coordinate systems</a>) of the _client area_ or _content area_ of the window. The window system may impose limits on window size.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga371911f12c74c504dd8d47d832d095cb" title="Sets the size of the client area of the specified window.">glfwSetWindowSize</a>(window, 640, 480);
</pre></div><p>For full screen windows, the specified size becomes the new resolution of the window's *desired video mode*. The video mode most closely matching the new desired video mode is set immediately. The window is resized to fit the resolution of the set video mode.</p>
<p>If you wish to be notified when a window is resized, whether by the user or the system, set a size callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#gaa40cd24840daa8c62f36cafc847c72b6" title="Sets the size callback for the specified window.">glfwSetWindowSizeCallback</a>(window, window_size_callback);
</pre></div><p>The callback function receives the new size, in screen coordinates, of the client area of the window when it is resized.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> window_size_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
{
}
</pre></div><p>There is also <a class="el" href="group__window.html#gaeea7cbc03373a41fb51cfbf9f2a5d4c6">glfwGetWindowSize</a> for directly retrieving the current size of a window.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> width, height;
<a class="code" href="group__window.html#gaeea7cbc03373a41fb51cfbf9f2a5d4c6" title="Retrieves the size of the client area of the specified window.">glfwGetWindowSize</a>(window, &amp;width, &amp;height);
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>Do not pass the window size to `glViewport` or other pixel-based OpenGL calls. The window size is in screen coordinates, not pixels. Use the [framebuffer size](<a class="el" href="window.html#window_fbsize">Framebuffer size</a>), which is in pixels, for pixel-based calls.</dd></dl>
<p>The above functions work with the size of the client area, but decorated windows typically have title bars and window frames around this rectangle. You can retrieve the extents of these with <a class="el" href="group__window.html#ga1a9fd382058c53101b21cf211898f1f1">glfwGetWindowFrameSize</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> left, top, right, bottom;
<a class="code" href="group__window.html#ga1a9fd382058c53101b21cf211898f1f1" title="Retrieves the size of the frame of the window.">glfwGetWindowFrameSize</a>(window, &amp;left, &amp;top, &amp;right, &amp;bottom);
</pre></div><p>The returned values are the distances, in screen coordinates, from the edges of the client area to the corresponding edges of the full window. As they are distances and not coordinates, they are always zero or positive.</p>
<h3><a class="anchor" id="window_fbsize">
Framebuffer size</a></h3>
<p>While the size of a window is measured in screen coordinates, OpenGL works with pixels. The size you pass into `glViewport`, for example, should be in pixels. On some machines screen coordinates and pixels are the same, but on others they will not be. There is a second set of functions to retrieve the size, in pixels, of the framebuffer of a window.</p>
<p>If you wish to be notified when the framebuffer of a window is resized, whether by the user or the system, set a size callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga3203461a5303bf289f2e05f854b2f7cf" title="Sets the framebuffer resize callback for the specified window.">glfwSetFramebufferSizeCallback</a>(window, framebuffer_size_callback);
</pre></div><p>The callback function receives the new size of the framebuffer when it is resized, which can for example be used to update the OpenGL viewport.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> framebuffer_size_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> width, <span class="keywordtype">int</span> height)
{
    glViewport(0, 0, width, height);
}
</pre></div><p>There is also <a class="el" href="group__window.html#ga0e2637a4161afb283f5300c7f94785c9">glfwGetFramebufferSize</a> for directly retrieving the current size of the framebuffer of a window.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> width, height;
<a class="code" href="group__window.html#ga0e2637a4161afb283f5300c7f94785c9" title="Retrieves the size of the framebuffer of the specified window.">glfwGetFramebufferSize</a>(window, &amp;width, &amp;height);
glViewport(0, 0, width, height);
</pre></div><p>The size of a framebuffer may change independently of the size of a window, for example if the window is dragged between a regular monitor and a high-DPI one.</p>
<h3><a class="anchor" id="window_pos">
Window position</a></h3>
<p>The position of a windowed-mode window can be changed with <a class="el" href="group__window.html#ga1abb6d690e8c88e0c8cd1751356dbca8">glfwSetWindowPos</a>. This moves the window so that the upper-left corner of its client area has the specified [screen coordinates](<a class="el" href="intro.html#coordinate_systems">Coordinate systems</a>). The window system may put limitations on window placement.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga1abb6d690e8c88e0c8cd1751356dbca8" title="Sets the position of the client area of the specified window.">glfwSetWindowPos</a>(window, 100, 100);
</pre></div><p>If you wish to be notified when a window is moved, whether by the user, system or your own code, set a position callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga2837d4d240659feb4268fcb6530a6ba1" title="Sets the position callback for the specified window.">glfwSetWindowPosCallback</a>(window, window_pos_callback);
</pre></div><p>The callback function receives the new position of the upper-left corner of the client area when the window is moved.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> window_pos_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> xpos, <span class="keywordtype">int</span> ypos)
{
}
</pre></div><p>There is also <a class="el" href="group__window.html#ga73cb526c000876fd8ddf571570fdb634">glfwGetWindowPos</a> for directly retrieving the current position of the client area of the window.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> xpos, ypos;
<a class="code" href="group__window.html#ga73cb526c000876fd8ddf571570fdb634" title="Retrieves the position of the client area of the specified window.">glfwGetWindowPos</a>(window, &amp;xpos, &amp;ypos);
</pre></div><h3><a class="anchor" id="window_title">
Window title</a></h3>
<p>All GLFW windows have a title, although undecorated or full screen windows may not display it or only display it in a task bar or similar interface. You can set a UTF-8 encoded window title with <a class="el" href="group__window.html#ga5d877f09e968cef7a360b513306f17ff">glfwSetWindowTitle</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga5d877f09e968cef7a360b513306f17ff" title="Sets the title of the specified window.">glfwSetWindowTitle</a>(window, <span class="stringliteral">&quot;My Window&quot;</span>);
</pre></div><p>The specified string is copied before the function returns, so there is no need to keep it around.</p>
<p>As long as your source file is encoded as UTF-8, you can use any Unicode characters directly in the source.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga5d877f09e968cef7a360b513306f17ff" title="Sets the title of the specified window.">glfwSetWindowTitle</a>(window, <span class="stringliteral">&quot;プラネテス&quot;</span>);
</pre></div><h3><a class="anchor" id="window_monitor">
Window monitor</a></h3>
<p>Full screen windows are associated with a specific monitor. You can get the handle for this monitor with <a class="el" href="group__window.html#gaeac25e64789974ccbe0811766bd91a16">glfwGetWindowMonitor</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__monitor.html#ga8d9efd1cde9426692c73fe40437d0ae3">GLFWmonitor</a>* monitor = <a class="code" href="group__window.html#gaeac25e64789974ccbe0811766bd91a16" title="Returns the monitor that the window uses for full screen mode.">glfwGetWindowMonitor</a>(window);
</pre></div><p>This monitor handle is one of those returned by <a class="el" href="group__monitor.html#ga3fba51c8bd36491d4712aa5bd074a537">glfwGetMonitors</a>.</p>
<p>For windowed mode windows, this function returns `NULL`. This is the recommended way to tell full screen windows from windowed mode windows.</p>
<h3><a class="anchor" id="window_iconify">
Window iconification</a></h3>
<p>Windows can be iconified (i.e. minimized) with <a class="el" href="group__window.html#ga1bb559c0ebaad63c5c05ad2a066779c4">glfwIconifyWindow</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga1bb559c0ebaad63c5c05ad2a066779c4" title="Iconifies the specified window.">glfwIconifyWindow</a>(window);
</pre></div><p>When a full screen window is iconified, the original video mode of its monitor is restored until the user or application restores the window.</p>
<p>Iconified windows can be restored with <a class="el" href="group__window.html#ga52527a5904b47d802b6b4bb519cdebc7">glfwRestoreWindow</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga52527a5904b47d802b6b4bb519cdebc7" title="Restores the specified window.">glfwRestoreWindow</a>(window);
</pre></div><p>When a full screen window is restored, the desired video mode is restored to its monitor as well.</p>
<p>If you wish to be notified when a window is iconified or restored, whether by the user, system or your own code, set a iconify callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#gab1ea7263081c0e073b8d5b91d6ffd367" title="Sets the iconify callback for the specified window.">glfwSetWindowIconifyCallback</a>(window, window_iconify_callback);
</pre></div><p>The callback function receives changes in the iconification state of the window.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> window_iconify_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> iconified)
{
    <span class="keywordflow">if</span> (iconified)
    {
        <span class="comment">// The window was iconified</span>
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// The window was restored</span>
    }
}
</pre></div><p>You can also get the current iconification state with <a class="el" href="group__window.html#gacccb29947ea4b16860ebef42c2cb9337">glfwGetWindowAttrib</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> iconified = <a class="code" href="group__window.html#gacccb29947ea4b16860ebef42c2cb9337" title="Returns an attribute of the specified window.">glfwGetWindowAttrib</a>(window, <a class="code" href="glfw3_8h.html#a39d44b7c056e55e581355a92d240b58a">GLFW_ICONIFIED</a>);
</pre></div><h3><a class="anchor" id="window_hide">
Window visibility</a></h3>
<p>Windowed mode windows can be hidden with <a class="el" href="group__window.html#ga49401f82a1ba5f15db5590728314d47c">glfwHideWindow</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga49401f82a1ba5f15db5590728314d47c" title="Hides the specified window.">glfwHideWindow</a>(window);
</pre></div><p>This makes the window completely invisible to the user, including removing it from the task bar, dock or window list. Full screen windows cannot be hidden and calling <a class="el" href="group__window.html#ga49401f82a1ba5f15db5590728314d47c">glfwHideWindow</a> on a full screen window does nothing.</p>
<p>Hidden windows can be shown with <a class="el" href="group__window.html#ga61be47917b72536a148300f46494fc66">glfwShowWindow</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga61be47917b72536a148300f46494fc66" title="Makes the specified window visible.">glfwShowWindow</a>(window);
</pre></div><p>Windowed mode windows can be created initially hidden with the `GLFW_VISIBLE` [window hint](<a class="el" href="window.html#window_hints_wnd">Window related hints</a>). Windows created hidden are completely invisible to the user until shown. This can be useful if you need to set up your window further before showing it, for example moving it to a specific location.</p>
<p>You can also get the current visibility state with <a class="el" href="group__window.html#gacccb29947ea4b16860ebef42c2cb9337">glfwGetWindowAttrib</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> visible = <a class="code" href="group__window.html#gacccb29947ea4b16860ebef42c2cb9337" title="Returns an attribute of the specified window.">glfwGetWindowAttrib</a>(window, <a class="code" href="glfw3_8h.html#afb3cdc45297e06d8f1eb13adc69ca6c4">GLFW_VISIBLE</a>);
</pre></div><h3><a class="anchor" id="window_focus">
Window input focus</a></h3>
<p>If you wish to be notified when a window gains or loses input focus, whether by the user, system or your own code, set a focus callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga25d1c584edb375d7711c5c3548ba711f" title="Sets the focus callback for the specified window.">glfwSetWindowFocusCallback</a>(window, window_focus_callback);
</pre></div><p>The callback function receives changes in the input focus state of the window.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> window_focus_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window, <span class="keywordtype">int</span> focused)
{
    <span class="keywordflow">if</span> (focused)
    {
        <span class="comment">// The window gained input focus</span>
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// The window lost input focus</span>
    }
}
</pre></div><p>You can also get the current input focus state with <a class="el" href="group__window.html#gacccb29947ea4b16860ebef42c2cb9337">glfwGetWindowAttrib</a>.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> focused = <a class="code" href="group__window.html#gacccb29947ea4b16860ebef42c2cb9337" title="Returns an attribute of the specified window.">glfwGetWindowAttrib</a>(window, <a class="code" href="glfw3_8h.html#a54ddb14825a1541a56e22afb5f832a9e">GLFW_FOCUSED</a>);
</pre></div><h3><a class="anchor" id="window_refresh">
Window damage and refresh</a></h3>
<p>If you wish to be notified when the contents of a window is damaged and needs to be refreshed, set a window refresh callback.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga4569b76e8ac87c55b53199e6becd97eb" title="Sets the refresh callback for the specified window.">glfwSetWindowRefreshCallback</a>(m_handle, window_refresh_callback);
</pre></div><p>The callback function is called when the contents of the window needs to be refreshed.</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> window_refresh_callback(<a class="code" href="group__window.html#ga3c96d80d363e67d13a41b5d1821f3242">GLFWwindow</a>* window)
{
    draw_editor_ui(window);
    <a class="code" href="group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14" title="Swaps the front and back buffers of the specified window.">glfwSwapBuffers</a>(window);
}
</pre></div><dl class="note"><dt><b>Note:</b></dt><dd>On compositing window systems such as Aero, Compiz or Aqua, where the window contents are saved off-screen, this callback might only be called when the window or framebuffer is resized.</dd></dl>
<h3><a class="anchor" id="window_attribs">
Window attributes</a></h3>
<p>Windows have a number of attributes that can be returned using <a class="el" href="group__window.html#gacccb29947ea4b16860ebef42c2cb9337">glfwGetWindowAttrib</a>. Some reflect state that may change during the lifetime of the window, while others reflect the corresponding hints and are fixed at the time of creation. Some are related to the actual window and others to its context.</p>
<div class="fragment"><pre class="fragment"><span class="keywordflow">if</span> (<a class="code" href="group__window.html#gacccb29947ea4b16860ebef42c2cb9337" title="Returns an attribute of the specified window.">glfwGetWindowAttrib</a>(window, <a class="code" href="glfw3_8h.html#a54ddb14825a1541a56e22afb5f832a9e">GLFW_FOCUSED</a>))
{
    <span class="comment">// window has input focus</span>
}
</pre></div><h4><a class="anchor" id="window_attribs_wnd">
Window related attributes</a></h4>
<p>`GLFW_FOCUSED` indicates whether the specified window has input focus. Initial input focus is controlled by the [window hint](<a class="el" href="window.html#window_hints_wnd">Window related hints</a>) with the same name.</p>
<p>`GLFW_ICONIFIED` indicates whether the specified window is iconified, whether by the user or with <a class="el" href="group__window.html#ga1bb559c0ebaad63c5c05ad2a066779c4">glfwIconifyWindow</a>.</p>
<p>`GLFW_VISIBLE` indicates whether the specified window is visible. Window visibility can be controlled with <a class="el" href="group__window.html#ga61be47917b72536a148300f46494fc66">glfwShowWindow</a> and <a class="el" href="group__window.html#ga49401f82a1ba5f15db5590728314d47c">glfwHideWindow</a> and initial visibility is controlled by the [window hint](<a class="el" href="window.html#window_hints_wnd">Window related hints</a>) with the same name.</p>
<p>`GLFW_RESIZABLE` indicates whether the specified window is resizable _by the user_. This is set on creation with the [window hint](<a class="el" href="window.html#window_hints_wnd">Window related hints</a>) with the same name.</p>
<p>`GLFW_DECORATED` indicates whether the specified window has decorations such as a border, a close widget, etc. This is set on creation with the [window hint](<a class="el" href="window.html#window_hints_wnd">Window related hints</a>) with the same name.</p>
<p>`GLFW_FLOATING` indicates whether the specified window is floating, also called topmost or always-on-top. This is controlled by the [window hint](<a class="el" href="window.html#window_hints_wnd">Window related hints</a>) with the same name.</p>
<h4><a class="anchor" id="window_attribs_ctx">
Context related attributes</a></h4>
<p>`GLFW_CLIENT_API` indicates the client API provided by the window's context; either `GLFW_OPENGL_API` or `GLFW_OPENGL_ES_API`.</p>
<p>`GLFW_CONTEXT_VERSION_MAJOR`, `GLFW_CONTEXT_VERSION_MINOR` and `GLFW_CONTEXT_REVISION` indicate the client API version of the window's context.</p>
<p>`GLFW_OPENGL_FORWARD_COMPAT` is `GL_TRUE` if the window's context is an OpenGL forward-compatible one, or `GL_FALSE` otherwise.</p>
<p>`GLFW_OPENGL_DEBUG_CONTEXT` is `GL_TRUE` if the window's context is an OpenGL debug context, or `GL_FALSE` otherwise.</p>
<p>`GLFW_OPENGL_PROFILE` indicates the OpenGL profile used by the context. This is `GLFW_OPENGL_CORE_PROFILE` or `GLFW_OPENGL_COMPAT_PROFILE` if the context uses a known profile, or `GLFW_OPENGL_ANY_PROFILE` if the OpenGL profile is unknown or the context is an OpenGL ES context. Note that the returned profile may not match the profile bits of the context flags, as GLFW will try other means of detecting the profile when no bits are set.</p>
<p>`GLFW_CONTEXT_ROBUSTNESS` indicates the robustness strategy used by the context. This is `GLFW_LOSE_CONTEXT_ON_RESET` or `GLFW_NO_RESET_NOTIFICATION` if the window's context supports robustness, or `GLFW_NO_ROBUSTNESS` otherwise.</p>
<h4><a class="anchor" id="window_attribs_fb">
Framebuffer related attributes</a></h4>
<p>The attributes of the default framebuffer (i.e. the framebuffer attached to the window) are not provided by this function but can be queried with both OpenGL and OpenGL ES.</p>
<p>If you are using version 3.0 or later of OpenGL or OpenGL ES, the `glGetFramebufferAttachmentParameteriv` function can be used to retrieve the number of bits for the red, green, blue, alpha, depth and stencil buffer channels. Otherwise, the `glGetIntegerv` function can be used.</p>
<p>The number of MSAA samples are always retrieved with `glGetIntegerv`. For contexts supporting framebuffer objects, the number of samples of the currently bound framebuffer is returned.</p>
<p>Attribute | glGetIntegerv | glGetFramebufferAttachmentParameteriv ------------ | ----------------- | ------------------------------------- Red bits | `GL_RED_BITS` | `GL_FRAMEBUFFER_ATTACHMENT_RED_SIZE` Green bits | `GL_GREEN_BITS` | `GL_FRAMEBUFFER_ATTACHMENT_GREEN_SIZE` Blue bits | `GL_BLUE_BITS` | `GL_FRAMEBUFFER_ATTACHMENT_BLUE_SIZE` Alpha bits | `GL_ALPHA_BITS` | `GL_FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE` Depth bits | `GL_DEPTH_BITS` | `GL_FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE` Stencil bits | `GL_STENCIL_BITS` | `GL_FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE` MSAA samples | `GL_SAMPLES` | _Not provided by this function_</p>
<p>When calling `glGetFramebufferAttachmentParameteriv`, the red, green, blue and alpha sizes can be queried from the `GL_BACK_LEFT`, while the depth and stencil sizes can be queried from the `GL_DEPTH` and `GL_STENCIL` attachments, respectively.</p>
<h2><a class="anchor" id="buffer_swap">
Buffer swapping</a></h2>
<p>GLFW windows are by default double buffered. That means that you have two rendering buffers; a front buffer and a back buffer. The front buffer is the one being displayed and the back buffer the one you render to.</p>
<p>When the entire frame has been rendered, it is time to swap the back and the front buffers in order to display what has been rendered and begin rendering a new frame. This is done with <a class="el" href="group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14">glfwSwapBuffers</a>.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14" title="Swaps the front and back buffers of the specified window.">glfwSwapBuffers</a>(window);
</pre></div><p>Sometimes it can be useful to select when the buffer swap will occur. With the function <a class="el" href="group__context.html#ga6d4e0cdf151b5e579bd67f13202994ed">glfwSwapInterval</a> it is possible to select the minimum number of monitor refreshes the driver wait should from the time <a class="el" href="group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14">glfwSwapBuffers</a> was called before swapping the buffers:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__context.html#ga6d4e0cdf151b5e579bd67f13202994ed" title="Sets the swap interval for the current context.">glfwSwapInterval</a>(1);
</pre></div><p>If the interval is zero, the swap will take place immediately when <a class="el" href="group__window.html#ga15a5a1ee5b3c2ca6b15ca209a12efd14">glfwSwapBuffers</a> is called without waiting for a refresh. Otherwise at least interval retraces will pass between each buffer swap. Using a swap interval of zero can be useful for benchmarking purposes, when it is not desirable to measure the time it takes to wait for the vertical retrace. However, a swap interval of one lets you avoid tearing.</p>
<p>Note that this may not work on all machines, as some drivers have user-controlled settings that override any swap interval the application requests. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<address class="footer">
<p>
Last update on 13 Dec 2016 for GLFW 3.1.2
</p>
</address>
</body>
</html>
